# 数据结构

## 二、算法

算法的时间复杂度  O(n)



## 三、线性表（list）

### 顺序存储：

顺序存储的优点：
1、逻辑结构与物理结构是统一的，其中的元素都是顺序存储的；
2、方法简单，好理解，各种语言中都有数组，易实现；
3、不用为结点间的逻辑关系而增加额外的存储空间；
4、表中数据元素可随机存取，顺序表具有按元素序号随机访问的特点；
5、存储密度大，存储密度为1（存储密度是指一个结点中数据元素所占的存储单元和整个结点所占的存储单元之比）。
顺序存储的缺点：
1、做插入、删除操作时，要移动大量元素，因此对很长的顺序表操作效率低，插入和删除操作不方便；
2、要预先分配存储空间，预先估计过大，会导致存储空间浪费，估计过小，会造成数据溢出。



### 链式存储：

链式存储的优点：
1、做插入、删除操作时很方便，不需要移动数据元素，动态性强；
2、不用预先估计存储空间的规模。
链式存储的缺点：
1、链式存储的操作是基于指针的，但不是所有的语言中都有指针类型；
2、对每个数据元素而言，除了自身信息外，还需要一起存放其后继存储单元的地址，这两部分共同组成一个结点；
3、存储密度小，存储密度小于1；
4、表中数据元素不可随机存取。



### 顺序存储和链式存储的比较和选择：

1、基于存储空间
顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。链表不用事先估计存储规模，但链表的存储密度较低。顺序存储结构的存储密度是1，而链式存储结构的存储密度小于1。
2、基于运算
在顺序表中按序号访问aiai的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)。
3、基于环境
顺序表容易实现，在任何高级语言中都有数组类型，链表的操作是基于指针的，相对来讲顺序表简单些。
总之，两种存储结构各有优势，选择哪一种结构依据实际问题而定。一般来讲，较稳定的线性表选择顺序存储，而频繁的做插入、删除操作的动态性较强的线性表选择链式存储更为合适。



### 单链的读取

从头开始找，找到第i个为止



### 单链的插入和删除

当链表的每个结点只包含一个指针域时，我们称此链表为单链表。

关于单链表的存取，有时候我们在单链表的第一个结点（有效元素）之前附设一个结点，称之为[头结点](http://www.nowamagic.net/librarys/veda/tag/头结点)；指向头结点的指针，称之为头指针；对单链表的存取必须从头指针开始进行，由于单链表的最后一个数据元素没有直接后继，则指针为NULL。



头节点好处

一、由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在链表的任意位置都一致，不需要做特殊处理。

二、无论链表是否为空，其头指针都会指向头结点，这样子空表和非空表的处理也就得到了统一。



对于头结点，数据域可以不存储任何信息，也可存储如链表长度等附加信息。



```c++
//L为头指针
//实现插入结点的关键代码如下：
p=GetElem(L,i-1);s->next=p->next;p->next=s;

//删除代码
p=GetElem(L,i-1);q=p->next;p->next=q->next;free(q);
```



### 单链表的创建

是动态创建的 （大小i，i作为计数器）

先创建一个带头节点的单链（空），然后一个一个创建，直到i



### 单链表整体删除

从第一个开始一个一个删除



### 静态链表（元素存放的地方是静态的，固定在一段的内存中）

用数组描述的链表

##### 相比于链表的特殊点

下表0的元素cur存放下一个可用空间（第一个）的下标

末尾存放着第一个元素开始的下标（999，存着第一个存放的下标地址2）

静态链表的插入删除



![截屏2021-10-18 上午11.22.23](/Users/ashina/Documents/GitHub/books-notes/数据结构/截屏2021-10-18 上午11.22.23.png)

优点：相比于顺序表，增删不用移动内存

缺点：无法随机读取数据（需要从头一个一个找）



### 循环链表（最后一个指向头结点）

可以随机从链表的一个结点出发，然后访问链表全部结点



### 双向链表（比单链表多一个前驱指针）



## 栈和队列（两种特殊的线性表）

### 栈 （后进先出）lifo

栈是限定仅在表尾*（栈顶）*进行插入和删除的线性表  

栈有顺序栈和链栈，特点：

#### 栈的应用——递归（递归时候用于记录函数的顺序）

#### 栈的应用——四则运算表达式求值

数字先进栈，遇到符号最近的两个数出栈进行运算，结果进栈，知道最后一个值出栈

```c++
9+(3-1)*3+10/2  //中缀表达式
9 3 1 - 3 * + 10 2 / +  //后缀表达式
9 3 1 进栈；
1，3出栈，3-1=2，2进栈 ，3 进栈 ；
3，2出栈，2*3=6 ，6 进栈；
6，9 出栈；9+6 = 15，15进栈；
10，2进栈；
10，2 出栈，10/2 = 5 ；进栈
15；5出栈；15+5 =20进栈；
20 出栈；
```

### 队列（先进先出）fifo

只允许在一端进行插入操作，在另外一端进行删除操作的线性表

#### 循环队列（顺序存储结构，好处，当数据出队时候其余数据不要移动）

头尾相联的顺序存储结构称为循环队列（必须有固定的大小长度）

#### 链队列（单链表，只能在头尾操作）



## 串（string）



## 树

树是n >=0个结点的有限集；

1. n=0，空树
2. 有且是有一个根结点
3. 其余结点部分互不相交

结点：根结点，内部节点，叶结点（端结点）

度：结点拥有的子树称为度

### 二叉树

1. 该树所有结点的度<=2
2. 左子树和右子树是有顺序的，不能颠倒；比如左右手

#### 性质

1. 在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
2. 深度为k的二叉树至多有2^k-1个结点(k>=1)
3. 对于任何一个二叉树T，如果终端结点为n，度为2的结点为k，则 n=k+1 （度为1的结点树为1）

#### 完全二叉树性质

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，

1. n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。

⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。

2. 对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

​       a）当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）

​       b）如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。

​       c）如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。

### 二叉树的遍历

从左到右

#### 1.前序遍历

#### 2.中序遍历

#### 3.后续遍历



#### 线索二叉树（充分利用空指针）

我们对二叉树以某种次序遍历使其变为线索二叉树的过程称为**线索化**

遍历二叉树后，将二叉树内的空指针指向前驱（后继），之后增加0，1变量确定为左/右



#### 树--->二叉树

<img src="/Users/ashina/Library/Application Support/typora-user-images/image-20211018171341208.png" alt="image-20211018171341208" style="zoom: 33%;" />

#### 森林--->二叉树

<img src="/Users/ashina/Documents/GitHub/books-notes/数据结构/截屏2021-10-18 下午5.16.11 下午5.18.11.png" alt="截屏2021-10-18 下午5.16.11 下午5.18.11" style="zoom: 33%;" />





#### 二叉树--->树

<img src="/Users/ashina/Library/Application Support/typora-user-images/image-20211018172353639.png" alt="image-20211018172353639" style="zoom:33%;" />

#### 二叉树---->森林

<img src="/Users/ashina/Library/Application Support/typora-user-images/image-20211018172740732.png" alt="image-20211018172740732" style="zoom:33%;" />

### 赫夫曼树（二叉树的应用）

根据先验知识调整分支结构判断的先后，比如80%的人都是80分一下，则有限判断 ？< 80

## 图

### 图的表示

#### 邻接矩阵 

1. 顶点数组
2. 边数组

#### 邻接表 （表述有向图有缺陷）

知道入度，但是要得到出度则需要遍历图

#### 逆邻接表

知道出度，但是要得到入度则需要遍历图

#### 十字链表

#### 边集数组



### 图的遍历

#### 深度优先遍历 （类似树的前序遍历）

#### 广度优先遍历（类似树的层序遍历）



### 最小生成树

构造连通网的最小代价生成树称为最小生成树

1. 普里姆算法O(n^2)

2. 克鲁斯卡尔算法（eloge）e为边数

   

### 最短路径

1. 狄杰斯特拉算法 O(n^2)  //求某一个顶点到其他各顶点的最短路径

   核心思想：算v1到v8 先算 v1到v2，再算v1到v3，。。。。v1到v8

2. 弗洛伊德算法O(n^3)  //各个顶点到其他顶点的最短路径（不能解决负权环）



### 拓扑排序

定义：
把AOV网（用定点表示活动，用弧表示活动间优先关系的有向图）络中各个顶点按照它们互相之间的优先关系排列成一个线性序列的过程叫做拓扑排序。

方法：

1. 在有向图中选一个没有前驱的顶点并且输出
2. 从图中删除该顶点和所有以它为尾的弧，即删除所有与它有关的边。
3. 重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止。

### 关键路径

 程序耗时的关键路径



## 查找

### 顺序表查找/线性查找

从头到位遍历

优化方式，在key，value查找时候，设置key作为哨兵，减少循环内计数器比较

```c++
//优化前
for(int i = 1 ; i < n ,i++){
  if (a[i]==key) return i ;
}

//优化后
if (a[0]==key){
  return 0;
}
a[0]=key;
i = n ；//n为a[]的尺寸
while（a[i]!= key）{
  i--;
}
return i;
```



### 有顺表查找

#### 一、二分法查找

使用二叉树方式

#### 二、插值查找（适用于分布均匀的数组）

这里，我们用一个公式来表示每次查找的期望索引值：

<img src="/Users/ashina/Documents/GitHub/books-notes/数据结构/截屏2021-10-19 下午6.04.16.png" alt="1" style="zoom:50%;" />

其中，`l` 和 `r` 分别代表数组的第一个和最后一个索引，`key`代表待查找的元素。

#### 三、斐波那契查找

预先设置斐波那契数列，按斐波那契数列来分割数组查找



### 线性索引查找

